package com.twjitm.transaction.service.zookeeper.impl;import com.twjitm.transaction.service.zookeeper.NettyTransactionZookeeperService;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.ZooDefs;import org.apache.zookeeper.ZooKeeper;import org.apache.zookeeper.data.Stat;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.CountDownLatch;/** * <p> * 利用zookeeper实现分布式事务锁，此类竟提供分布式事务相关的 * 业务使用，不能用做服务注册和服务发现等业务。否者将会造成数据丢失。 *</p> * @author twjitm - [Created on 2018-08-28 13:50] * @company https://github.com/twjitm * @jdk java version "1.8.0_77" */public class NettyTransactionZookeeperServiceImpl implements        NettyTransactionZookeeperService {    private Logger logger = LoggerFactory.getLogger(            NettyTransactionZookeeperServiceImpl.class);    private CountDownLatch countDownLatch = new CountDownLatch(1);    private ZooKeeper zooKeeper;    private String rootNode;    private String address;    public void setAddress(String address) {        this.address = address;    }    public void setRootNode(String rootNode) {        this.rootNode = rootNode;    }    public void init() {        logger.info("初始化zookeeper服务器");        if (this.zooKeeper == null) {            zooKeeper = connectZookeeperServer();        }        initRootNode();    }    /**     * 初始化更节点     */    public void initRootNode() {        try {            Stat s = zooKeeper.exists(rootNode, false);            if (s != null) {                return;            }            logger.info("创建分布式锁根节点服务：" + rootNode);            createRootNode(rootNode, new byte[0]);        } catch (Exception e) {            e.printStackTrace();            logger.info("创建分布式锁根节点服务：" + rootNode + "失敗");        }    }    /**     * 链接到zookeeper 服务器     *     * @return     */    private ZooKeeper connectZookeeperServer() {        ZooKeeper zk = null;        String hostAndPort = address;        try {            zk = new ZooKeeper(hostAndPort, 50000,                    event -> countDownLatch.countDown());        } catch (Exception e) {            logger.info("连接到zookeeper发生异常");            logger.error("连接到zookeeper异常", e);        }        logger.info("连接到zookeeper成功:" + hostAndPort);        return zk;    }    @Override    public boolean createNode(String nodePath, String nodeData) {        try {            //拼上更节点            nodePath = getRealLockPath(nodePath);            Stat s = zooKeeper.exists(nodePath, false);            if (s == null) {                byte[] data = nodeData.getBytes();                create(nodePath, data);                logger.info("创建zookeeper根节点： " + nodeData);            }            return true;        } catch (Exception e) {            logger.error(e.toString(), e);        }        return false;    }    @Override    public boolean exist(String nodePath) {        nodePath = getRealLockPath(nodePath);        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return true;            }        } catch (KeeperException | InterruptedException e) {            e.printStackTrace();        }        return false;    }    private String getRealLockPath(String node) {        return rootNode + "/" + node;    }    @Override    public boolean deleteNode(String nodePath) {        try {            zooKeeper.delete(getRealLockPath(nodePath), -1);            logger.debug("delete zookeeper node path c ({} => {})", nodePath);        } catch (Exception e) {            logger.error(e.toString(), e);        }        return true;    }    /**     * 创建持久态的znode,比支持多层创建.比如在创建/parent/child的情况下,无/parent.无法通过     *     * @param path     * @param data     * @throws KeeperException     * @throws InterruptedException     */    private void createRootNode(String path, byte[] data) throws Exception {        /**         * 此处采用的是CreateMode是PERSISTENT  表示The znode will not be automatically deleted upon client's disconnect.         * EPHEMERAL 表示The znode will be deleted upon the client's disconnect.         */        this.zooKeeper.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    /**     * 创建持久态的znode,比支持多层创建.比如在创建/parent/child的情况下,无/parent.无法通过     *     * @param path     * @param data     * @throws KeeperException     * @throws InterruptedException     */    private String create(String path, byte[] data) throws Exception {        /**         * 此处采用的是CreateMode是EPHEMERAL         * <p>         * PERSISTENT  表示The znode will not be automatically deleted upon         * 客户端即使关闭的时，zookeeper节点不会删除         * client's disconnect.         * EPHEMERAL 表示The znode will be deleted upon the client's disconnect.         * 当客户端关闭的时候，zookeeper会自动删除         * </p>         */        return this.zooKeeper.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }}