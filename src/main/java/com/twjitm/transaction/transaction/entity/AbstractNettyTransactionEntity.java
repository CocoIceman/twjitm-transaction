package com.twjitm.transaction.transaction.entity;import com.twjitm.transaction.lock.NettyTransactionLock;import com.twjitm.transaction.lock.NettyTransactionLockInterface;import com.twjitm.transaction.lock.NettyTransactionReadLock;import com.twjitm.transaction.service.redis.NettyTransactionRedisService;import com.twjitm.transaction.transaction.enums.NettyTransactionEntityCause;import com.twjitm.transaction.transaction.enums.NettyTransactionLockType;import com.twjitm.transaction.transaction.exception.NettyTransactionException;import java.util.BitSet;/** * 基于redis实现分布式事物锁 * 抽象事物实体类，所有的事物锁实体必须继承 * 本抽象类，实现自己的commit后的方法和rollback方法等用户实现方法 * <p> * 这些方法不是创建锁或者回滚锁方法，而是实现的是业务方法。需要注意的是 * 不能再次方法中创建和锁字段一样的字段，否者造成数据一致性错误 * * @author EGLS0807 - [Created on 2018-08-27 11:48] * @company http://www.g2us.com/ * @jdk java version "1.8.0_77" */public abstract class AbstractNettyTransactionEntity implements NettyTransactionEntityInterface {    /**     * 进度设置集合 主要用于rollback     */    private BitSet progressBitSet;    /**     * 事务锁     */    private NettyTransactionLockInterface nettyTransactionLock;    /**     * 锁类型     */    private NettyTransactionLockType nettyTransactionLockType;    /**     * 锁的正向标志(主要用于读取的时候)     */    private boolean rejectFlag = false;    public AbstractNettyTransactionEntity(NettyTransactionEntityCause cause,                                          String key,                                          NettyTransactionRedisService redisService) {        this.progressBitSet = new BitSet();        this.nettyTransactionLock = new NettyTransactionLock(key, redisService, cause);        this.nettyTransactionLockType = NettyTransactionLockType.WRITE;    }    /**     * 抽象分布式事物实体     *     * @param cause                    事物产生原因     * @param key                      事物key     * @param redisService             事物支持的redis服务     * @param nettyTransactionLockType 事物锁类型     */    public AbstractNettyTransactionEntity(NettyTransactionEntityCause cause,                                          String key,                                          NettyTransactionRedisService redisService,                                          NettyTransactionLockType nettyTransactionLockType) {        this.progressBitSet = new BitSet();        if (nettyTransactionLockType.equals(NettyTransactionLockType.READ)) {            this.nettyTransactionLock = new NettyTransactionReadLock(key, redisService, cause);            this.nettyTransactionLockType = NettyTransactionLockType.READ;        } else {            this.nettyTransactionLock = new NettyTransactionLock(key, redisService, cause);            this.nettyTransactionLockType = NettyTransactionLockType.WRITE;        }    }    public AbstractNettyTransactionEntity(NettyTransactionEntityCause cause,                                          String key,                                          NettyTransactionRedisService redisService,                                          NettyTransactionLockType nettyTransactionLockType, int lockTime) {        this.progressBitSet = new BitSet();        if (nettyTransactionLockType.equals(NettyTransactionLockType.READ)) {            this.nettyTransactionLock = new NettyTransactionReadLock(key, redisService, cause);            this.nettyTransactionLockType = NettyTransactionLockType.READ;        }        //独占锁        else if (nettyTransactionLockType.equals(NettyTransactionLockType.FORCE_WRITE_TIME)) {            this.nettyTransactionLock = new NettyTransactionLock(key, redisService, cause, lockTime, true);        } else {            //非独占锁            this.nettyTransactionLock = new NettyTransactionLock(key, redisService, cause, lockTime, false);        }        this.nettyTransactionLockType = nettyTransactionLockType;    }    /**     * 是否能够创建事物锁     *     * @param seconds     * @return     * @throws NettyTransactionException     */    @Override    public boolean createNettyTransactionLock(long seconds) throws NettyTransactionException {        boolean result = nettyTransactionLock.create(seconds);        if (rejectFlag) {            result = !result;        }        return result;    }    public void setRejectFlag(boolean rejectFlag) {        this.rejectFlag = rejectFlag;    }    /**     * 释放锁     */    @Override    public void releaseNettyTransactionLock() {        if (this.nettyTransactionLockType.equals(NettyTransactionLockType.FORCE_WRITE_TIME) || this.nettyTransactionLockType.equals(NettyTransactionLockType.WRITE_TIME)) {            return;        }        this.nettyTransactionLock.destroy();    }    /**     * 记录事务提交的进度，用于回滚操作。     * 根据进度进行不同程度的回滚     *     * @param step     */    public void setTransactionCommitProgress(int step) {        if (progressBitSet != null) {            progressBitSet.set(step);        }    }    /**     * 检查事物锁所处于的进度状态     *     * @param step     * @return     */    public boolean checkTransactionCommitProgress(int step) {        return this.progressBitSet.get(step);    }    @Override    public String getInfo() {        return this.nettyTransactionLock.getInfo();    }    /**     * 强制释放锁     */    @Override    public void forceReleaseNettyTransactionLock() {        this.nettyTransactionLock.destroy();    }    @Override    public boolean needCommit() {        return !this.nettyTransactionLockType.equals(NettyTransactionLockType.READ);    }    @Override    public NettyTransactionLockInterface getNettyTransactionLockInterface() {        return this.nettyTransactionLock;    }    public BitSet getProgressBitSet() {        return progressBitSet;    }}